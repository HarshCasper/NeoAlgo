/*
Problem : 
	Given an array of size N. Find the total sum of all the subarrays in the array.

Problem Explanation:

	Suppose that we have an array [1,2,3] with N = 3. Now we need to find the total sum of all the subarrays. Lets first start by listing out the subarrays.
	The subarrays would be : 
	[],
	[1], [1,2], [1,2,3],
	[2], [2,3],
	[3]
	From here, we can find the sum of each subarrays and add them together to get the result. 

-->Naive method :

	The bruteforce method would be to  find the subarrays starting from a particular index and calculating the sum of each subarrays and finally adding to the total answer.
	But if we notice, we can see that the number of subarrays generated by the element at index = 0 is 3, index = 1 is 2 and index = 2 is 1.
	Generally speaking we can say that the number of subarrays from an element at ith index would be (N - i)
	i.e. by 0th index, it would be (N - 0) = N subarrays
	     by 1st index, it would be (N - 1) = N - 1 subarrays and so on and finally by (N - 1)th index would be (N - (N - 1)) = 1

	Therefore, finding subarrays will require (N) + (N-1) + (N-2) + ... + (1) = N * (N + 1) / 2.
	Hence the total time complexity would be O(N^2).

-->Efficient Method : (USING REVERSE LOOKUP)

	In this method, the main intution is to get the number of times a particular element is repeated in a subarray.
	Once we have the repetition number, we can multiply the element with the number of times it is repeated in order to get the actual contribution of that element towards the final sum.
	
	For example, let's say we have an element with value X placed at i-th position in the array. Now for X to be included in a subarray, that particular subarray must start from any index between 0 to i and must end between any indicies from i to N-1.
	Hence the number of subarrays starting from index 0 to i = i + 1 
	and the number of subarrays ending on indices from i to N-1  = N - i

	Therefore, the total number of repetitions = (i + 1) * (N - i)
	The contribution by X = X * repetitions  = X * ((i + 1) * (N - i)).

	Hence the total time complexity would just be O(N).

Note : In order to avoid overflows while adding, use Modular arithmethic
-> (a + b) % M = ((a % M) + (b % M)) % M
-> (a * b) % M = ((a % M) * (b % M)) % M
where, M = 10^9 + 7

*/

#include <bits/stdc++.h>
using namespace std;

//initializing the mod value to avoid overflows
const long long M = 1e9 + 7;

int main(){
	int n, value; 
	cin >> n;

	//contribution variable denotes the contribution from a particular element
	long long contribution, total_sum = 0;
	vector<int> array;

	//reading the elements to the array
	for(int i = 0; i < n; i++){
		cin >> value;
		array.push_back(value);
	}

	for(int i = 0; i < n; i++){
		//actual contribution by array[i] is array[i] * ((i + 1) * (N - i))
        contribution = ((( i + 1) % M * ( n - i ) % M ) % M * array[i] % M ) % M;
        //total_sum = total_sum + contribution
        total_sum = ((total_sum % M) + (contribution % M)) % M;
    }

    cout << total_sum;

	return 0;
}


/*
Input : 
6
2 3 4 7 8 9

Output:
308

Time Complexity : O(n)
Space Complexity : O(1)

*/